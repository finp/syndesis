<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Developing {prodname} extensions :: Docs</title>
    <meta name="generator" content="Antora 2.3.1">
    <link rel="stylesheet" href="../../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">Docs</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
         
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="is-primary" href="#"></a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../../index.html">Docs</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../index.html"> Home</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Docs</span>
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Docs</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../../index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../../index.html">Docs</a></li>
    <li><a href="assembly-developing-extensions.html">Developing {prodname} extensions</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///home/pwright/repos/doc-test/syndesis/antora/modules/ROOT/pages/integrating-applications/assemblies/customizing/assembly-developing-extensions.adoc"></a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Developing {prodname} extensions</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>If {prodname} does not provide a feature that is needed to create an
integration, then an expert developer
can code an extension that provides the needed behavior.  The Syndesis
extension repository,
<a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a>,
contains examples of extensions.</p>
</div>
<div class="paragraph">
<p>A business integrator shares requirements with a developer who codes the
extension. The developer provides a <code>.jar</code> file that contains the extension.
The business integrator uploads the <code>.jar</code> file in {prodname} to make the
custom connector, custom step(s), or library resource available for use
in {prodname}.</p>
</div>
<div class="paragraph">
<p>The Fuse Tooling plugin to Red Hat Developer Studio provides a wizard
that helps you develop a step extension or a connector extension. It is
a matter of personal preference whether you choose to develop a step
extension or a connector extension in Developer Studio or in some other
IDE. For information about using the Developer Studio plugin, see
<a href="{LinkToolingUserGuide}#FuseOnlineExtension">Developing extensions for {prodname} integrations</a>.</p>
</div>
<div class="paragraph">
<p>In this document, the following topics outline the
procedure, describe the requirements, and provide additional examples for
developing extensions in an IDE that you choose.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#procedure-for-developing-extensions_extensions">General procedure for developing extensions</a></p>
</li>
<li>
<p><a href="#description-kinds-extensions_extensions">Description of the kinds of extensions</a></p>
</li>
<li>
<p><a href="#overview-extension-content-structure_extensions">Overview of extension content and structure</a></p>
</li>
<li>
<p><a href="#about-extension-definitions_extensions">Requirements in an extension definition JSON file</a></p>
</li>
<li>
<p><a href="#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a></p>
</li>
<li>
<p><a href="#using-maven-to-generate-extension-definitions_extensions">Description of Maven plugin that supports extensions</a></p>
</li>
<li>
<p><a href="#how-to-specify-data-shapes_extensions">How to specify data shapes in extensions</a></p>
</li>
<li>
<p><a href="#develop-step-extensions_extensions">Examples of developing step extensions</a></p>
</li>
<li>
<p><a href="#develop-connector-extensions_extensions">Example of developing a connector extension</a></p>
</li>
<li>
<p><a href="#develop-library-extensions_extensions">How to develop library extensions</a></p>
</li>
<li>
<p><a href="#creating-jdbc-driver-library-extensions_extensions">Creating JDBC driver library extensions</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="procedure-for-developing-extensions_extensions"><a class="anchor" href="#procedure-for-developing-extensions_extensions"></a>General procedure for developing extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before you start to develop an extension, become familiar with the tasks that
you will need to accomplish.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>Familiarity with <a href="https://maven.apache.org/">Maven</a></p>
</li>
<li>
<p>Familiarity with <a href="https://camel.apache.org/">Camel</a> if you are developing an extension that provides
a connector or that provides an integration step that operates on data between connections</p>
</li>
<li>
<p>Experience programming</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An integration pod runs in a Java process with a flat classpath.
To avoid version clashes, make sure that the dependencies that an extension
uses are aligned with the imported bill of materials (BOM) from all of
these sources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.boot:spring-boot-dependencies:$SPRING_BOOT_VERSION</code></p>
</li>
<li>
<p><code>org.apache.camel:camel-spring-boot-dependencies:$CAMEL_VERSION</code></p>
</li>
<li>
<p><code>io.syndesis.integration:integration-bom:$SYNDESIS_VERSION</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there are additional dependencies that are not part of the imported BOMs,
you must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Package them in the extension JAR file that is in the <code>lib</code> directory.</p>
</li>
<li>
<p>Omit them from the <code>dependencies</code> property of the extension&#8217;s JSON descriptor file.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Obtain an understanding of what the extended feature must do.
Talk to your business colleague to understand the feature requirements.</p>
</li>
<li>
<p>Determine whether you need to develop a step extension, a connector extension,
or a library extension.</p>
</li>
<li>
<p>Set up the Maven project in which to develop the extension.</p>
</li>
<li>
<p>If you are developing a step extension:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Decide whether to implement it as a Camel route or implement it by using
the Syndesis <code>Step</code> API. Information for the Syndesis API is at
<a href="http://javadoc.io/doc/io.syndesis.extension/extension-api" class="bare">http://javadoc.io/doc/io.syndesis.extension/extension-api</a>.</p>
</li>
<li>
<p>If you choose to implement the extension as a Camel route,
decide whether to implement XML fragments, a <code>RouteBuilder</code> class, or a bean.</p>
</li>
<li>
<p>In your Maven project, specify the required metadata, such as the
<code>schemaVersion</code>, extension <code>name</code>, <code>extensionId</code>, and so on.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Code the classes that implement the feature.</p>
</li>
<li>
<p>Add dependencies to the project&#8217;s <code>pom.xml</code> file.</p>
</li>
<li>
<p>For connector and library extensions, and for step extensions that
you implement in XML, create the JSON file that
defines the extension.</p>
<div class="paragraph">
<p>For step extensions that you implement in Java,
Maven can generate the JSON extension definition file
for you when you specify corresponding data structure values in your Maven project.</p>
</div>
</li>
<li>
<p>Run Maven to build the extension and create the extension&#8217;s JAR file.</p>
</li>
<li>
<p>Test the extension by uploading the JAR file to a {prodname} development environment.</p>
</li>
<li>
<p>Provide the JAR file that packages the extension to your business colleague,
who uploads it to a
{prodname} production environment. When you provide the JAR file, let your
business colleague know about any configuration settings that require
information beyond what appears in the {prodname} web interface.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="description-kinds-extensions_extensions"><a class="anchor" href="#description-kinds-extensions_extensions"></a>Description of the kinds of extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An extension defines one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>One or more custom steps that operate on integration data between
connections. Each custom step performs one action. This is a step extension.</p>
</li>
<li>
<p>A library resource that an integration runtime uses. For example,
a library extension can provide a JDBC driver for connecting to a proprietary
SQL database, such as Oracle.</p>
</li>
<li>
<p>A single custom connector for creating connections to a particular application
or service that you want to integrate. This is a connector extension.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
{prodname} can use an OpenAPI document to create a connector
for a REST API client. See
<a href="{LinkSyndesisIntegrationGuide}#developing-rest-api-client-connectors_custom">Develop a REST API client connector</a>.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>A business integrator shares requirements with a developer who codes the extension.
The developer provides a <code>.jar</code> file that contains the extension.
The business integrator uploads the <code>.jar</code> file in {prodname} to make the custom connector,
custom step(s), or library resource available for use within {prodname}.</p>
</div>
<div class="paragraph">
<p>An extension <code>.jar</code> file that you upload to {prodname} always contains
exactly one extension.</p>
</div>
<div class="paragraph">
<p>For an example of uploading and using an extension that provides a step
that operates on data between connections, see the
<a href="{LinkSyndesisTutorials}#amq-to-rest-api_tutorials">AMQ to REST API sample integration tutorial</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview-extension-content-structure_extensions"><a class="anchor" href="#overview-extension-content-structure_extensions"></a>Overview of extension content and structure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An extension is a collection of classes, dependencies, and resources
that are packaged in a <code>.jar</code> file.</p>
</div>
<div class="paragraph">
<p>{prodname} uses Spring Boot to load an extension. Consequently, you must
package an extension according to Spring Boot&#8217;s executable JAR format.
For example, ensure that you use the <code>ZipEntry.STORED()</code> method to save
a nested JAR file.</p>
</div>
<div class="paragraph">
<p>The structure of a <code>.jar</code> file that packages an extension is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>extension.jar
|
+- META-INF
|  |
|  +- syndesis
|     |
|     +- syndesis-extension-definition.json <i class="conum" data-value="1"></i><b>(1)</b>
|
+- mycompany
|  |
|  +-project
|    |
|    +-YourClasses.class <i class="conum" data-value="2"></i><b>(2)</b>
|
+- lib <i class="conum" data-value="3"></i><b>(3)</b>
  |
  +-dependency1.jar
  |
  +-dependency2.jar</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A JSON schema file that specifies the data structures that
define the extension. This is referred to as the extension definition JSON file.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The Java classes that implement the behavior that the extension
provides.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Additional dependencies that are required to build and
execute the custom feature.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about-extension-definitions_extensions"><a class="anchor" href="#about-extension-definitions_extensions"></a>Requirements in an extension definition JSON file</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Each extension must have a <code>.json</code> file that defines the extension
by specifying values for data structures such as name, description,
supported actions, and dependencies. For each extension type, the
following table indicates whether Maven can generate the
extension definition JSON file and which data structures are required.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 16.6666%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Extension Type</th>
<th class="tableblock halign-left valign-top">Maven Can Generate Extension Definition</th>
<th class="tableblock halign-left valign-top">Required Data Structures</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Step extension in Java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br>
<code>name</code><br>
<code>description</code><br>
<code>version</code><br>
<code>extensionId</code><br>
<code>extensionType</code><br>
<code>actions</code><br>
<code>dependencies</code> *</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Step extension in XML</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br>
<code>name</code><br>
<code>description</code><br>
<code>version</code><br>
<code>extensionId</code><br>
<code>extensionType</code><br>
<code>actions</code><br>
<code>dependencies</code> *</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connector extension</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br>
<code>name</code><br>
<code>description</code><br>
<code>version</code><br>
<code>extensionId</code><br>
<code>extensionType</code><br>
<code>properties</code><br>
<code>actions</code><br>
<code>dependencies</code> *<br>
<code>componentScheme</code><br>
<code>connectorCustomizers</code><br>
<code>connectorFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Library extension</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schemaVersion</code><br>
<code>name</code><br>
<code>description</code><br>
<code>version</code><br>
<code>extensionId</code><br>
<code>extensionType</code><br>
<code>dependencies</code> *</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>*While specification of <code>dependencies</code> is not strictly required,
in practice, there are almost always dependencies that you need
to specify.</p>
</div>
<div class="paragraph">
<p>Typically, an extension definition file has the following layout:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schemaVersion": "v1",
  "name": "",
  "description": "",
  "version": "",
  "extensionId": "",
  "extensionType": "",
  "properties": {
  },
  "actions": [
  ],
  "dependencies": [
  ],
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>schemaVersion</strong> defines the version of the extension definition schema.
Internally, Syndesis uses <strong>schemaVersion</strong> to determine how to map the
extension definition to the
internal model. This allows extensions that were developed against an old version of
Syndesis to be deployed on newer versions of Syndesis.</p>
</li>
<li>
<p><strong>name</strong> is the name of the extension. When you upload an extension
to {prodname}, this name appears.</p>
</li>
<li>
<p><strong>description</strong> is any useful information that you want to specify.
{prodname} does not operate on this value.</p>
</li>
<li>
<p><strong>version</strong> is for your convenience to help you distinguish updates
to an extension. {prodname} does not operate on this value.</p>
</li>
<li>
<p><strong>extensionId</strong> defines a unique ID for the extension. This should be unique
at least across a Syndesis environment.</p>
</li>
<li>
<p><strong>extensionType</strong> indicates to Syndesis what the extension provides. As of
Syndesis version 1.3, the following extension types are supported:</p>
<div class="ulist">
<ul>
<li>
<p><code>Steps</code></p>
</li>
<li>
<p><code>Connectors</code></p>
</li>
<li>
<p><code>Libraries</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>properties</strong> at the top level in a connector extension is required. It controls
what {prodname} displays when a {prodname} user selects the connector
to create a connection. This <code>properties</code> object contains a set
of properties for each form control for creating a connection.
For example:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"myControlName": {
  "deprecated": true|false,
  "description": "",
  "displayName": "",
  "group": "",
  "kind": "",
  "label": "",
  "required": true|false,
  "secret": true|false,
  "javaType": "",
  "type": "",
  "defaultValue": "",
  "enum": {
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In connector extensions, nested <code>properties</code> objects define HTML form controls for
configuring connection actions.
In step extensions, the <code>actions</code> object contains a <code>properties</code>
object. The <code>properties</code> object defines a set of properties for
each form control for configuring the step. See also:
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p>
</div>
</li>
<li>
<p><strong>actions</strong> defines the operations that a connector can perform or the
operation that a step between connections can perform. Only connector
and step extensions use actions that you specify.
The format for an action specification looks like this:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "id": "",
    "name": "",
    "description": "",
    "actionType": "step|connector",
    "descriptor": {
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>id</strong> is a unique ID for the action. This should be unique at least
within a Syndesis environment.</p>
</li>
<li>
<p><strong>name</strong> is the action name that appears in {prodname}. An integrator
sees this value as the name of a connection action or as the name of a step
that operates on integration data between connections.</p>
</li>
<li>
<p><strong>description</strong> is the action description that appears in {prodname}.
Use this field to help the integrator understand what the action does.</p>
</li>
<li>
<p><strong>actionType</strong> indicates whether the action is performed by a connection
or a step that is between connections.</p>
</li>
<li>
<p><strong>descriptor</strong> specifies nested attributes such as <code>kind</code>, <code>entrypoint</code>,
<code>inputDataType</code>, <code>outputDatatype</code> and more.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>dependencies</strong> defines the resources that this extension
requires {prodname} to provide.</p>
<div class="paragraph">
<p>Define a dependency as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "MAVEN",
  "id"   : "org.apache.camel:camel-telegram:jar:2.21.0"
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>type</strong> indicates the type of the dependency. Specify <strong>MAVEN</strong>. (It is
expected that other types will be supported in the future.)</p>
</li>
<li>
<p><strong>id</strong> is the ID of the Maven dependency, which is a Maven GAV.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="descriptions-of-user-interface-properties-in-extension-definitions_extensions"><a class="anchor" href="#descriptions-of-user-interface-properties-in-extension-definitions_extensions"></a>Descriptions of user interface properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In connector extensions and step extensions, specify user interface
properties in the extension definition JSON file or in Java class files.
The settings of these
properties define the HTML form controls that {prodname} displays when a
{prodname} user creates a connection, configures a connection action,
or configures a step that is provided by the extension.</p>
</div>
<div class="paragraph">
<p>You must specify properties for each form control that you want to appear
in the extension&#8217;s user interface in the {prodname} console.
For each form control, specify some or all properties in any order.</p>
</div>
<div class="paragraph">
<div class="title">Example of user interface property specifications</div>
<p>In the JSON file that is part of the IRC connector, the top level
<code>properties</code> object defines the HTML form controls that appear after
a {prodname} user selects the IRC connector to create a connection.
There are three sets of property definitions for three
form controls: <code>hostname</code>, <code>password</code>, and <code>port</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"properties": {
   "hostname": {
     "description": "IRC Server hostname",
     "displayName": "Hostname",
     "labelHint": "Hostname of the IRC server to connect to",
     "order": "1",
     "required": true,
     "secret": false,
     "type": "string"
   },
   "password": {
     "description": "IRC Server password",
     "displayName": "Password",
     "labelHint": "Required if IRC server requires it to join",
     "order": "3",
     "required": false,
     "secret": true,
     "type": "string"
   },
   "port": {
     "description": "IRC Server port",
     "displayName": "Port",
     "labelHint": "Port of the IRC server to connect to",
     "order": "2",
     "required": true,
     "secret": false,
     "tags": [],
     "type": "int"
   }
 },</code></pre>
</div>
</div>
<div class="paragraph">
<p>Based on these property specifications, when a {prodname} user selects
the IRC connector, {prodname} displays the following dialog. After
the user enters values in the two required fields and clicks
<strong>Next</strong>, {prodname} creates an IRC connection that is configured
with the values that the {prodname} user enters.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../_images/images/integrating-applications/IRC-create-connection-fields.png" alt="Hostname" width="Password" height="Port"></span></p>
</div>
<div class="paragraph">
<div class="title">About <code>properties</code> objects in extension definition JSON files</div>
<p>In a connector extension:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The toplevel <code>properties</code> object is required. It controls
what {prodname} displays when a {prodname} user selects the connector
to create a connection. This <code>properties</code> object contains a set
of properties for each form control for creating a connection.</p>
</li>
<li>
<p>In the <code>actions</code> object, there is a <code>properties</code> object for each
action. In each of these <code>properties</code> objects, there is a set
of properties for each form control for configuring that action.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In a step extension, the <code>actions</code> object contains a <code>properties</code>
object. The <code>properties</code> object defines a set of properties for
each form control for configuring the step. The JSON hierarchy
looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"actions": [
   {
      ...

      "propertyDefinitionSteps": [
         {
            ...

            "properties":
               {
                  "control-ONE": {
                     "type": "string",
                     "displayName": "Topic Name",
                     "order": "2",
                     ...,
                     }

                  "control-TWO": {
                     "type": "boolean",
                     "displayName": "Urgent",
                     "order": "3",
                     ...
                     }

                  "control-THREE": {
                     "type": "textarea",
                     "displayName": "Comment",
                     "order": "1",
                     ...,
                     }
 } } ]</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">About user interface properties in Java files</div>
<p>To define user interface form controls in Java files, import
<code>io.syndesis.extension.api.annotations.ConfigurationProperty</code> in each class
file that defines user configuration of a connection, action, or step.
For each form control that you want the {prodname} console to display,
specify the <code>@ConfigurationProperty</code> annotation, followed by a list of
properties. For information about the properties that you can specify,
see the user interface property reference table at the end of this section.</p>
</div>
<div class="paragraph">
<p>The following code shows property definitions for one form control.
This code is in the example of developing a Camel route with <code>RouteBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public class LogAction extends RouteBuilder {
    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")</pre>
</div>
</div>
<div class="paragraph">
<p>The following code shows property definitions for two controls.
This code is from the example of using the Syndesis Step API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Action(id = "split", name = "Split", description = "Split your exchange")
public class SplitAction implements Step {

    @ConfigurationProperty(
        name = "language",
        displayName = "Language",
        description = "The language used for the expression")
    private String language;

    @ConfigurationProperty(
        name = "expression",
        displayName = "Expression",
        description = "The expression used to split the exchange
     private String language;</pre>
</div>
</div>
<div class="paragraph">
<div class="title">Descriptions of control form input types</div>
<p>In the set of properties for each HTML form control, the <code>type</code>
property defines the input type of the form control that {prodname} displays.
For details about HTML form input types, see
<a href="https://www.w3schools.com/html/html_form_input_types.asp">https://www.w3schools.com/html/html_form_input_types.asp</a>.</p>
</div>
<div class="paragraph">
<p>The following table lists the possible input types for {prodname} form
controls. In the set of properties for a control, if you specify a
<code>type</code> value that is unknown, {prodname} displays an input field that accepts
one line of text. That is, the default is <code>"type": "text"</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value of <code>type</code> property</th>
<th class="tableblock halign-left valign-top">HTML</th>
<th class="tableblock halign-left valign-top">{prodname} displays</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="checkbox"&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A checkbox that the user can select or not select.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>duration</code></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">A custom control that lets the {prodname} user select a unit of time:
milliseconds, seconds, minutes, hours, or days. The user also enters
a number and {prodname} returns a number of milliseconds. For example:<br>
<code>"properties": {<br>
&nbsp;&nbsp;&nbsp;"period": {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type": "duration"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"defaultValue": 60000,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"description": "Period",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"displayName": "Period",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"labelHint": "Delay between integration executions.",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"required": true,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"secret": false,<br>
&nbsp;&nbsp;&nbsp;} <br>
}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hidden</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="hidden"&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field does not appear in the {prodname} console. You can use
other properties to specify data that is associated with this field,
for example, textual data of some kind.
While {prodname} users cannot see or modify this data,
if a user selects
<strong>View Source</strong> for a {prodname} page, hidden fields are visible
in the source display. Therefore, do not use hidden fields for
security purposes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code>, <code>integer</code>, <code>long</code>, <code>number</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="number"&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An input field that accepts a number.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="password"&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An input field in which {prodname} masks the characters
that the user enters, typically with asterisks.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>select</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>&lt;select&gt;</code> element, for example:<br>
<code>&lt;select name="targets"&gt;<br>
&nbsp;&nbsp;&lt;option value="queue"&gt;Queue&lt;/option&gt;<br>
&nbsp;&nbsp;&lt;option value="topic"&gt;Topic&lt;/option&gt;<br>
&lt;/select&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A drop-down list with an entry for each label/value pair
that you specify in the form controlâ€™s <code>enum</code> property.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code>, <code>string</code>, or any unknown value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="text"&gt;`</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An input field that accepts one line of text.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>textarea</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;input type="textarea"</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A textarea element is used</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">Descriptions of control form user interface properties</div>
<p>In a connector or step extension, for each HTML form control that
appears in the {prodname} console, you can specify one or more of the
properties described in the following table.
For details about HTML form input types, see
<a href="https://www.w3schools.com/html/html_form_input_types.asp">https://www.w3schools.com/html/html_form_input_types.asp</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property name</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls the kind of form control that {prodname} displays. See
the previous table for details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cols</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>textarea</code> field, controls the number of columns initially
displayed for the textarea control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>controlHint</code> or <code>controlTooltip</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set, the value is mapped to the HTML <code>title</code> attribute of the form
control element. Just like other elements that have a <code>title</code> attribute,
when the cursor hovers over the control, a tooltip appears. The content
of the tooltip comes from the value of the <code>controlHint</code>
or <code>controlTooltip</code> property.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dataList</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the value of the <code>type</code> property is <code>text</code>, {prodname} uses
the value of the <code>dataList</code> property to add typeahead support. Specify
an array of strings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Varies according to the value of the <code>type</code> property.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{prodname} initially displays this value in the form field.
The type of the setting of the <code>defaultValue</code> property should match the
value of the <code>type</code> property. For example, when the <code>type</code> property is
set to <code>number</code>, the <code>defaultValue</code> setting should be a number.
If the user does not change this initial field value,
{prodname} uses <code>defaultValue</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set, {prodname} displays this value below the form control.
Typically, this is a short, useful message about the control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{prodname} displays this value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set, {prodname} overrides any setting for the <code>type</code> property
and implements a <code>select</code> control. Specify the array as a set of
<code>label</code> and <code>value</code> attributes. The <code>label</code> attribute appears
in the user interface as the select item&#8217;s label. The <code>value</code>
attribute becomes the value for the corresponding select item.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>labelHint</code> or <code>labelTooltip</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set, a <code>?</code> icon appears next to the display name. When the
{prodname} user clicks the <code>?</code> icon, the value of the <code>labelHint</code>
property displays.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>max</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>number</code> field, defines the highest acceptable value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>min</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set for a <code>number</code> field, defines the lowest acceptable value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multiple</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to <code>true</code> for a <code>select</code> field or for a field that has
the <code>enum</code> property set, {prodname} displays a multi-select control
instead of a select drop-down.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines the order of controls in the {prodname} console.
{prodname} applies ascending order, that is, the control that
has <code>"order": "1"</code> appears first.
Without specification of the <code>order</code> property, {prodname} displays
controls in the order in which the JSON file defines them.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>placeholder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set, {prodname} displays this value in a hazed font in an
input field to help the user understand the expected input.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>required</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls whether or not the <code>required</code> attribute is set on the control.
If true, then the {prodname} user must enter a value for this control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rows</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the value of the <code>type</code> property is <code>textarea</code>,
the value of the <code>rows</code> property controls the number of rows
initially displayed in the textarea control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>secret</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If specified, {prodname} changes the setting of the control&#8217;s <code>type</code> property
to <code>password</code> if that is not already the setting.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="using-maven-to-generate-extension-definitions_extensions"><a class="anchor" href="#using-maven-to-generate-extension-definitions_extensions"></a>Description of Maven plugin that supports extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>extension-maven-plugin</code> supports extension development by
packaging the extension as a valid Spring Boot module. For step extensions
that you implement in Java, this plugin can generate the
extension definition JSON file.</p>
</div>
<div class="paragraph">
<p>In your Maven project&#8217;s <code>pom.xml</code> file, add the following plugin declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
    &lt;artifactId&gt;extension-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${syndesis.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
        &lt;goals&gt;
            &lt;goal&gt;generate-metadata&lt;/goal&gt;
            &lt;goal&gt;repackage-extension&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>extension-maven-plugin</code> defines the following goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>generate-metadata</strong> generates the JSON extension definition file
that will be in the generated JAR file as follows:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Maven starts with the data structure specifications that are in the
<code>META-INF/syndesis/syndesis-extension-definition.json</code> file, if there
is one.</p>
<div class="paragraph">
<p>If you are coding in XML, then you must define the extension
definition JSON file yourself and it must specify all required
data structures.</p>
</div>
<div class="paragraph">
<p>If you are developing a connector or library extension, then you must
define the extension definition JSON file yourself and it must specify
all required data structures.</p>
</div>
<div class="paragraph">
<p>If you are developing a step extension in Java, you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create the extension definition JSON file yourself.</p>
</li>
<li>
<p>In your Java code, specify annotations that define all
required data structures. You do not create an extension definition
JSON file.</p>
</li>
<li>
<p>Create an extension definition JSON file and specify some but
not all  data structures.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For step extensions that you develop in Java,
Maven obtains missing specifications from code annotations</p>
</li>
<li>
<p>Maven adds the dependencies list, which specifies dependencies that are
provided with a scope of <code>provided</code> and that are managed through the
<code>extension-bom</code>.</p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>repackage-extension</strong> packages the extension.</p>
<div class="ulist">
<ul>
<li>
<p>Dependencies and related transitive dependencies
that are not managed through the <code>extension-bom</code> are in the <code>lib</code> folder
of the generated JAR.</p>
</li>
<li>
<p>For library extensions, dependencies whose scope is <code>system</code> are
in the <code>lib</code> folder of the generated JAR.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, suppose your Maven project has the following <code>pom.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.company&lt;/groupId&gt;
  &lt;artifactId&gt;my-extension&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;name&gt;MyExtension&lt;/name&gt;
  &lt;description&gt;A Sample Extension&lt;/description&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
        &lt;artifactId&gt;extension-bom&lt;/artifactId&gt;
        &lt;version&gt;1.3.10&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
      &lt;artifactId&gt;extension-api&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.github.lalyos&lt;/groupId&gt;
      &lt;artifactId&gt;jfiglet&lt;/artifactId&gt;
      &lt;version&gt;0.0.8&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.8&lt;/source&gt;
          &lt;target&gt;1.8&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
        &lt;artifactId&gt;extension-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.3.10&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;generate-metadata&lt;/goal&gt;
              &lt;goal&gt;repackage-extension&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Based on this <code>pom.xml</code> file, the generated extension definition
JSON file looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "name": "MyExtension",
  "description": "A Sample Extension",
  "extensionId": "com.company:my-extension",
  "version": "1.0.0",
  "dependencies": [ {
    "type": "MAVEN",
    "id": "io.syndesis.extension:extension-api:jar:1.3.10"
  } ],
  "extensionType": "Libraries",
  "schemaVersion": "v1"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated archive has this structure and content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>my-extension-1.0.0.jar
|
+- lib
|  |
|Â Â + jfiglet-0.0.8.jar
|
+- META-INF
  |
  +- MANIFEST.MF
     |
     +- syndesis
        |
        +- syndesis-extension-definition.json</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-to-specify-data-shapes_extensions"><a class="anchor" href="#how-to-specify-data-shapes_extensions"></a>How to specify data shapes in extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A data shape holds data type metadata for use by the data mapper.
The data mapper transforms this metadata into internal documents that
it uses to display the source and target data fields in the data mapper
user interface. In an extension definition JSON file for a connector or
for a custom step, each action specification defines an input
data shape (<code>inputDataShape</code>) and an output data shape (<code>outputDataShape</code>).</p>
</div>
<div class="paragraph">
<p>When you are developing an extension, it is important to specify data
shape properties that allow the data mapper to correctly handle and display the
source and target fields. The following data shape properties affect
data mapper behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>kind</code></p>
</li>
<li>
<p><code>type</code></p>
</li>
<li>
<p><code>specification</code></p>
</li>
<li>
<p><code>name</code></p>
</li>
<li>
<p><code>description</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">About the <code>kind</code> property</div>
<p>The data shape <code>kind</code> property is represented by the <code>DataShapeKinds</code> enum.
The possible values for the <code>kind</code> property are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java</code> indicates that the data type is represented by a Java class.
Follow the <code>"kind": "java"</code> declaration by specifying a fully qualified
class name for the <code>type</code> property. For example:</p>
<div class="listingblock">
<div class="content">
<pre>"outputDataShape": {
     "kind": "java",
     "type": "org.apache.camel.component.telegram.model.IncomingMessage"
},</pre>
</div>
</div>
</li>
<li>
<p><code>json-schema</code> indicates that the data type is represented by a JSON schema.
When <code>kind</code> is set to <code>json-schema</code>, specify a JSON schema as the value of
the data shape&#8217;s <code>specification</code> property. For example:</p>
<div class="listingblock">
<div class="content">
<pre>"inputDataShape": {
  "description": "Person data",
  "kind": "json-schema",
  "name": "Person",
  "specification": "{\"$schema\":\"http://json-schema.org/draft-04/schema#\",\"title\":\"Person\",\"type\":\"object\",\"properties\":{\"firstName\":{...}}}"
}</pre>
</div>
</div>
<div class="paragraph">
<p>The code for the SAP Concur connector contains
<a href="https://github.com/syndesisio/syndesis/blob/master/app/connector/concur/src/main/resources/META-INF/syndesis/connector/concur-api.json">examples of data shapes that are specified by JSON schemas</a>.</p>
</div>
</li>
<li>
<p><code>json-instance</code> indicates that the data type is represented by a JSON instance.
When <code>kind</code> is set to <code>json-instance</code>, specify a JSON instance as the value of
the data shape&#8217;s <code>specification</code> property. For example:</p>
<div class="listingblock">
<div class="content">
<pre>"inputDataShape": {
  "description": "Person data",
  "kind": "json-instance",
  "name": "Person",
  "specification": "{\"firstName\":\"John\",...}"
}</pre>
</div>
</div>
</li>
<li>
<p><code>xml-schema</code> indicates that the data type is represented by an XML schema.
When <code>kind</code> is set to <code>xml-schema</code>, specify an XML Schema as the value of
the data shape&#8217;s <code>specification</code> property. For example:</p>
<div class="listingblock">
<div class="content">
<pre>"inputDataShape": {
  "description": "Person data",
  "kind": "xml-schema",
  "name": "Person",
  "specification": "&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"&gt;...&lt;/xs:schema&gt;"
}</pre>
</div>
</div>
</li>
<li>
<p><code>xml-instance</code> indicates that the data type is represented by an XML instance.
When <code>kind</code> is set to <code>xml-instance</code>, specify an XML instance as the value of
the data shape&#8217;s <code>specification</code> property. For example:</p>
<div class="listingblock">
<div class="content">
<pre>"inputDataShape": {
  "description": "Person data",
  "kind": "xml-instance",
  "name": "Person",
  "specification": "&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;Person&gt;&lt;firstName&gt;Jane&lt;/firstName&gt;&lt;/Person&gt;"
}</pre>
</div>
</div>
</li>
<li>
<p><code>any</code> indicates that the data type is not structured. For example, it might
be a byte array or free format text. The data mapper ignores a data shape when
its <code>kind</code> property is set to <code>any</code>.
In other words, the data does not appear in the data mapper and therefore
you cannot map any fields to or from this data.</p>
<div class="paragraph">
<p>However, for a custom connector, when its <code>kind</code> property is set to <code>any</code>,
{prodname} prompts you to specify input and/or output data types when you
configure a connection that you have created from the custom connector.
This happens when you add a connection to an integration.
You can specify the kind of the data shapeâ€™s schema, an appropriate
document for the kind of schema that you specify, and a name for the data type.</p>
</div>
</li>
<li>
<p><code>none</code> indicates that there is no data type. For an input data shape,
this indicates that the connection or step does not read data. For an output data shape,
this indicates that the connection or step does not modify data. For example, when
an input message body is being transferred to an output message body,
setting the <code>kind</code> property to <code>none</code> indicates that the data is only passing
through. The data mapper ignores data shapes when <code>kind</code> is set to <code>none</code>.
In other words, the data does not appear in the data mapper and therefore
you cannot map any fields to or from this data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">About the <code>type</code> property</div>
<p>When the value of the <code>kind</code> property is <code>java</code>, the <code>"kind": "java"</code>
declaration is followed by a <code>type</code> declaration that specifies a fully qualified
Java class name. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>"outputDataShape": {
     "kind": "java",
     "type": "org.apache.camel.component.telegram.model.IncomingMessage"
},</pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>kind</code> property is set to anything other than <code>java</code> then any
setting for the <code>type</code> property is ignored.</p>
</div>
<div class="paragraph">
<div class="title">About the <code>specification</code> property</div>
<p>The setting of the <code>kind</code> property determines the setting of the
<code>specification</code> property, as shown in the following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>kind</code> property setting</th>
<th class="tableblock halign-left valign-top"><code>specification</code> property setting</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java inspection result.</p>
<p class="tableblock">For each extension that you write in Java, use <code>extension-maven-plugin</code>
to at least obtain the Java inspection result. The plugin inserts the Java
inspection result in the JSON extension definition file as the setting
of the <code>specification</code> property. This is the only way to obtain the Java
inspection result, which is required for data mapping in {prodname}.</p>
<p class="tableblock">As a reminder, for step extensions written in Java, <code>extension-maven-plugin</code>
generates the JSON extension definition file and populates it with
required content. For connector extensions, while <code>extension-maven-plugin</code>
inserts the Java inspection result in the JSON extension definition file,
you will need to manually
add the required content that the plugin does not insert.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>json-schema</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An actual JSON schema document. The setting cannot be a reference to a
document and the JSON schema cannot point to other JSON schema documents
by means of references.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>json-instance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An actual JSON document that contains example data. The data mapper
derives the data types from the example data. The setting cannot be a
reference to a document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xml-schema</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An actual XML schema document. The setting cannot be a reference to a
document and the XML schema cannot point to other XML schema documents
by means of references.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xml-instance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An actual
XML instance document. The setting cannot be a reference to a document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>any</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>specification</code> property is not required. Any setting is ignored.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>specification</code> property is not required. Any setting is ignored.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">About the <code>name</code> property</div>
<p>The data shape <code>name</code> property specifies a human readable name for the
data type. The data mapper displays this name in its user interface
as the label for the data fields. In the following image,
<strong>Twitter Mention</strong> is an example of where you would see the value of
the <code>name</code> property.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../../_images/images/integrating-applications/TwitterMention.png" alt="Name example"></span></p>
</div>
<div class="paragraph">
<p>This name also appears in data type indicators in the {prodname}
flow visualization.</p>
</div>
<div class="paragraph">
<div class="title">About the <code>description</code> property</div>
<p>The data shape <code>description</code> property specifies text that appears as a
tooltip when the cursor hovers over the data type name in the data mapper
user interface.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="develop-step-extensions_extensions"><a class="anchor" href="#develop-step-extensions_extensions"></a>Examples of developing step extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A step extension implements one or more custom steps.
Each custom step implements one action for processing integration data
between connections.
The following examples demonstrate the alternatives for developing
step extensions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#example-route-xml-fragment_step-alternatives">Example of developing a Camel route with XML fragments</a></p>
</li>
<li>
<p><a href="#example-route-builder_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code></a></p>
</li>
<li>
<p><a href="#example-route-builder-spring-boot_step-alternatives">Example of developing a Camel route with <code>RouteBuilder</code> and Spring Boot</a></p>
</li>
<li>
<p><a href="#example-camel-bean_step-alternatives">Example of using a Camel bean</a></p>
</li>
<li>
<p><a href="#example-step-api_step-alternatives">Example of using the Syndesis Step API</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Syndesis provides custom Java annotations that you can use in
conjunction with the <code>syndesis-extension-plugin</code>.  When you implement
a step extension or a connector extension in Java, you can specify annotations
that enable Maven to add action definitions to the extension definition JSON file.
To enable annotation processing,  add
the following dependency to your Maven project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.syndesis.extension&lt;/groupId&gt;
  &lt;artifactId&gt;extension-annotation-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because Spring Boot is the integration runtime, to inject beans
into a Camel context, be sure to follow standard Spring Boot
practices. For example,
<a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/boot-features-developing-auto-configuration.html">create an auto configuration class</a>
and create beans there. However, the default behavior is that
extension code is not subject to package scanning. Consequently,
you must create and populate the <code>META-INF/spring.factories</code> file
in a step extension.</p>
</div>
<div class="sect2">
<h3 id="example-route-xml-fragment_step-alternatives"><a class="anchor" href="#example-route-xml-fragment_step-alternatives"></a>Example of developing a Camel route with XML fragments</h3>
<div class="paragraph">
<p>To develop a custom step, you can implement the action as an XML fragment that
is a Camel route that has an input such as <code>direct</code>. The Syndesis runtime
invokes this route in the same way that it invokes any other Camel route.</p>
</div>
<div class="paragraph">
<p>For example, suppose that you want to create a step that logs the body of a
message with an optional prefix. The following XML defines a Camel route
that does this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;routes xmlns="http://camel.apache.org/schema/spring"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://camel.apache.org/schema/spring
      http://camel.apache.org/schema/spring/camel-spring.xsd"&gt;

  &lt;route id="log-body-with-prefix"&gt;
    &lt;from uri="direct:log"/&gt;
    &lt;choice&gt;
      &lt;when&gt;
        &lt;simple&gt;${header.prefix} != ''&lt;/simple&gt;
        &lt;log message="${header.prefix} ${body}"/&gt;
      &lt;/when&gt;
      &lt;otherwise&gt;
        &lt;log message="Output ${body}"/&gt;
      &lt;/otherwise&gt;
    &lt;/choice&gt;
  &lt;/route&gt;

&lt;/routes&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you develop an extension in XML, you must create the extension
definition JSON file yourself. For this XML fragment, the
<code>src/main/resources/META-INF/syndesis/syndesis-extension-definition.json</code>
file could define the action as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "actionType": "step",
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <i class="conum" data-value="1"></i><b>(1)</b>
    "entrypoint": "direct:log", <i class="conum" data-value="2"></i><b>(2)</b>
    "resource": "classpath:log-body-action.xml", <i class="conum" data-value="3"></i><b>(3)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
  "propertyDefinitionSteps": [ {
    "description": "extension-properties",
    "name": "extension-properties",
    "properties": { <i class="conum" data-value="4"></i><b>(4)</b>
      "prefix": {
        "componentProperty": false,
        "deprecated": false,
        "description": "The Log body prefix message",
        "displayName": "Log Prefix",
        "javaType": "String",
        "kind": "parameter",
        "required": false,
        "secret": false,
        "type": "string"
      }
    }
  } ]
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The type of the action is set to <code>ENDPOINT</code>. The runtime invokes a
Camel endpoint to execute the action provided by this custom step.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The Camel endpoint to invoke is <code>direct:log</code>. This is the <code>from</code> specification
in the route.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is the location of the XML  fragment.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>These are the properties that the action defined in this custom step
exposes to the integrator who will be adding this step to an integration. In
{prodname}, each value that the integrator specifies in the user interface
gets mapped to a message header that has the same name as the property.
In this example, the integrator will see one input field, with the
<strong>Log Prefix</strong> display name. For more details, see
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Syndesis does not support full Camel XML configuration. Syndesis supports
only the &lt;routes&gt; tag.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="example-route-builder_step-alternatives"><a class="anchor" href="#example-route-builder_step-alternatives"></a>Example of developing a Camel route with <code>RouteBuilder</code></h3>
<div class="paragraph">
<p>You can implement a custom step by developing an action as a Camel
route with the support of the <code>RouteBuilder</code> class. Such a route
has an input such as <code>direct</code>. Syndesis invokes this route in the same
way that it invokes any other Camel route.</p>
</div>
<div class="paragraph">
<p>To implement the example that creates a step that logs the body of a
message with an optional prefix, you can write something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.apache.camel.builder.RouteBuilder;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action( <i class="conum" data-value="1"></i><b>(1)</b>
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix",
    entrypoint = "direct:log")
public class LogAction extends RouteBuilder {
    @ConfigurationProperty( <i class="conum" data-value="2"></i><b>(2)</b>
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Override
    public void configure() throws Exception {
        from("direct::start") <i class="conum" data-value="3"></i><b>(3)</b>
            .choice()
                .when(simple("${header.prefix} != ''"))
                    .log("${header.prefix} ${body}")
                .otherwise()
                    .log("Output ${body}")
            .endChoice();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Action</code> annotation indicates the action definition.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@ConfigurationProperty</code> annotation indicates definitions of
user interface form controls. For details, see
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is the action implementation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This Java code uses Syndesis annotations, which means that the
<code>extension-maven-plugin</code> can automatically generate the action definition.
In the extension definition JSON file, the action definition will look
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <i class="conum" data-value="1"></i><b>(1)</b>
    "entrypoint": "direct:log", <i class="conum" data-value="2"></i><b>(2)</b>
    "resource": "class:io.syndesis.extension.log.LogAction", <i class="conum" data-value="3"></i><b>(3)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": { <i class="conum" data-value="4"></i><b>(4)</b>
        "prefix": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The type of action is <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action that this step implements.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the Camel endpoint to invoke. It is the <code>from</code> specification in the route.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is the class that implements <code>RoutesBuilder</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>These are the properties that the action defined in this custom step
exposes to the integrator who will be adding this step to an integration. In
{prodname}, each value that the integrator specifies in the user interface
gets mapped to a message header that has the same name as the property.
In this example, the integrator will see one input field, with the
<strong>Log Prefix</strong> display name. For more information, see
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="example-route-builder-spring-boot_step-alternatives"><a class="anchor" href="#example-route-builder-spring-boot_step-alternatives"></a>Example of developing a Camel route with <code>RouteBuilder</code> and Spring Boot</h3>
<div class="paragraph">
<p>You can implement a custom step by developing an action as a Camel
route with the support of the <code>RouteBuilder</code> class as well as Spring Boot.
In this example, Spring Boot is the facility for registering a
<code>RouteBuilder</code> object in a Camel context.
Syndesis invokes this route in the same
way that it invokes any other Camel route.</p>
</div>
<div class="paragraph">
<p>To implement the example that creates a step that logs the body of a
message with an optional prefix, you can write something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ActionsConfiguration {

    @Action( <i class="conum" data-value="1"></i><b>(1)</b>
        id = "log-body-with-prefix",
        name = "Log body with prefix",
        description = "A simple body log with a prefix",
        entrypoint = "direct:log")
    @ConfigurationProperty( <i class="conum" data-value="2"></i><b>(2)</b>
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    @Bean <i class="conum" data-value="3"></i><b>(3)</b>
    public RouteBuilder logBodyWithprefix() {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct::start") <i class="conum" data-value="4"></i><b>(4)</b>
                    .choice()
                        .when(simple("${header.prefix} != ''"))
                            .log("${header.prefix} ${body}")
                        .otherwise()
                            .log("Output ${body}")
                    .endChoice();
             }
        };
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Action</code> annotation indicates the action definition.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@ConfigurationProperty</code> annotation indicates definitions of
user interface form controls. For details, see
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Register the <code>RouteBuilder</code> object as a bean.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This is the action implementation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This Java code uses Syndesis annotations, which means that the
<code>extension-maven-plugin</code> can automatically generate the action definition.
In the extension definition JSON file, the action definition will look
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <i class="conum" data-value="1"></i><b>(1)</b>
    "entrypoint": "direct:log", <i class="conum" data-value="2"></i><b>(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": { <i class="conum" data-value="3"></i><b>(3)</b>
        "prefix": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The type of action is <code>ENDPOINT</code>. The runtime invokes a Camel endpoint to execute the action that this step implements.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the Camel endpoint to invoke. It is the <code>from</code> specification in the route.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>These are the properties that the action defined in this custom step
exposes to the integrator who will be adding this step to an integration. In
{prodname}, each value that the integrator specifies in the user interface
gets mapped to a message header that has the same name as the property.
In this example, the integrator will see one input field, with the
<strong>Log Prefix</strong> display name. For more details, see
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To make configuration classes discoverable by Spring Boot, you
must list them in a file named <code>META-INF/spring.factories</code>, for example:</p>
</div>
<div class="paragraph">
<p><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.company.ActionsConfiguration</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With Spring Boot, every bean that you eventually register in your
configuration classes is available to the Camel context. For details, see
the Spring Boot documentation for
<a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/boot-features-developing-auto-configuration.html">Creating your own auto-configuration</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="example-camel-bean_step-alternatives"><a class="anchor" href="#example-camel-bean_step-alternatives"></a>Example of using a Camel bean</h3>
<div class="paragraph">
<p>You can implement a custom step by developing an action as a Camel bean processor.
To implement the example that creates a step that logs the body of a
message with an optional prefix, you can write something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.apache.camel.Header;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Handler <i class="conum" data-value="1"></i><b>(1)</b>
    public void process(@Header("prefix") String prefix, @Body Object body) {
        if (prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", prefix, body);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the function that implements the action.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This Java code uses Syndesis annotations, which means that the
<code>extension-maven-plugin</code> can automatically generate the action definition.
In the extension definition JSON file, the action definition will look
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "BEAN", <i class="conum" data-value="1"></i><b>(1)</b>
    "entrypoint": "io.syndesis.extension.log.LogAction::process", <i class="conum" data-value="2"></i><b>(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "prefix": { <i class="conum" data-value="3"></i><b>(3)</b>
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The type of the action is <code>BEAN</code>. The runtime invokes a Camel bean processor
to execute the action in this custom step.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the Camel bean to invoke.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>These are the properties that the action defined in this custom step
exposes to the integrator who will be adding this step to an integration. In
{prodname}, each value that the integrator specifies in the user interface
gets mapped to a message header that has the same name as the property.
In this example, the integrator will see one input field, with the
<strong>Log Prefix</strong> display name. For more details, see
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you use beans, you might find it convenient to
inject user properties into the bean
instead of retrieving them from the exchange header. To do this, implement
getter and setter methods for the properties that you want to get injected.
The action implementation would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    public void setPrefix(String prefix) { <i class="conum" data-value="1"></i><b>(1)</b>
        this.prefix = prefix;
    }

    public String getPrefix() { <i class="conum" data-value="2"></i><b>(2)</b>
        return prefix;
    }

    @Handler
    public void process(@Body Object body) {
        if (this.prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", this.prefix, body);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the property setter method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the property getter method.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="example-step-api_step-alternatives"><a class="anchor" href="#example-step-api_step-alternatives"></a>Example of using the Syndesis Step API</h3>
<div class="paragraph">
<p>You can implement a custom step by using the Syndesis <code>Step</code> API. This
provides a way to interact with runtime route creation. You can use
any method provided by the <code>ProcessorDefinition</code> class and you can
create more complex routes. Information for the Syndesis API is at
<a href="http://javadoc.io/doc/io.syndesis.extension/extension-api" class="bare">http://javadoc.io/doc/io.syndesis.extension/extension-api</a>.</p>
</div>
<div class="paragraph">
<p>Here is an example of a step extension
that uses the Syndesis <code>Step</code> API to implement a split action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Map;
import java.util.Optional;

import io.syndesis.extension.api.Step;
import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;
import org.apache.camel.CamelContext;
import org.apache.camel.model.ProcessorDefinition;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.Expression;
import org.apache.camel.builder.Builder;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseOriginalAggregationStrategy;
import org.apache.camel.spi.Language;

@Action(id = "split", name = "Split", description = "Split your exchange")
public class SplitAction implements Step {

    @ConfigurationProperty(
        name = "language",
        displayName = "Language",
        description = "The language used for the expression")
    private String language;

    @ConfigurationProperty(
        name = "expression",
        displayName = "Expression",
        description = "The expression used to split the exchange")
    private String expression;

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }

    public String getExpression() {
        return expression;
    }

    public void setExpression(String expression) {
        this.expression = expression;
    }

    @Override
    public Optional&lt;ProcessorDefinition&gt; configure(
            CamelContext context,
            ProcessorDefinition route,
            Map&lt;String, Object&gt; parameters) { <i class="conum" data-value="1"></i><b>(1)</b>

        String languageName = language;
        String expressionDefinition = expression;

        if (ObjectHelper.isEmpty(languageName) &amp;&amp; ObjectHelper.isEmpty(expressionDefinition)) {
            route = route.split(Builder.body());
        } else if (ObjectHelper.isNotEmpty(expressionDefinition)) {

            if (ObjectHelper.isEmpty(languageName)) {
                languageName = "simple";
            }

            final Language splitLanguage = context.resolveLanguage(languageName);
            final Expression splitExpression = splitLanguage.createExpression(expressionDefinition);
            final AggregationStrategy aggreationStrategy = new UseOriginalAggregationStrategy(null, false);

            route = route.split(splitExpression).aggregationStrategy(aggreationStrategy);
        }

        return Optional.of(route);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the implementation of the action that the custom step performs.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This Java code uses Syndesis annotations, which means that the
<code>extension-maven-plugin</code> can automatically generate the action definition.
In the extension definition JSON file, the action definition will look
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id": "split",
  "name": "Split",
  "description": "Split your exchange",
  "descriptor": {
    "kind": "STEP", <i class="conum" data-value="1"></i><b>(1)</b>
    "entrypoint": "io.syndesis.extension.split.SplitAction", <i class="conum" data-value="2"></i><b>(2)</b>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "language": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The language used for the expression",
          "displayName": "Language",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        },
        "expression": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The expression used to split the exchange",
          "displayName": "Expression",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "tags": [],
  "actionType": "step"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The type of the action is <code>STEP</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the class that is implementing the <code>Step</code> interface.</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">Additional resource</div>
<p>For details about user interface properties, see
<a href="{LinkSyndesisIntegrationGuide}#descriptions-of-user-interface-properties-in-extension-definitions_extensions">Descriptions of user interface properties</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="develop-connector-extensions_extensions"><a class="anchor" href="#develop-connector-extensions_extensions"></a>Example of developing a connector extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If {prodname} does not provide a connector for the application or
service that you want to connect to in an integration,
an experienced developer can code an extension that contributes a
new connector to {prodname}. This documentation provides an introduction
to developing a connector extension. For details about developing a
connector, see
<a href="https://syndesis.io/docs/connectors/">Developing Syndesis connectors</a>
on the Syndesis community site.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For connector extensions, it is not yet possible to automatically generate the
extension definition JSON file from Java code.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A connector is essentially a proxy for a Camel component. A connector configures the
underlying component and creates endpoints according to
options that are defined in the extension definition and in
user-supplied options that the {prodname} web interface collects.</p>
</div>
<div class="paragraph">
<p>The connector extension definition extends the extension definition
that is required for step extensions with the following additional data
structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>componentScheme</code></p>
<div class="paragraph">
<p>Defines the Camel component that the connector uses.
You can set <code>componentScheme</code> for the connector or for actions.
If you set <code>componentScheme</code> for both the connector and an action,
the setting for the action has precedence.</p>
</div>
</li>
<li>
<p><code>connectorCustomizers</code></p>
<div class="paragraph">
<p>Specifies a list of classes that implement the
<a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyCustomizer.java">ComponentProxyCustomizer</a>
class. Each class customizes the behavior of a connector. For example,
a class might manipulate
properties before they are applied to the underlying component/endpoint,
or a class might add pre/post endpoint logic. For each class, specify
the full class name of the implementation, for example, <code>com.mycomponent.MyCustomizer</code>.
You can set <code>connectorCustomizers</code> on actions as well as connectors.
According to what is set,
{prodname} applies customizers to the connector first and then to
actions.</p>
</div>
</li>
<li>
<p><code>connectorFactory</code></p>
<div class="paragraph">
<p>Defines the class that implements the
<a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyFactory.java">ComponentProxyFactory</a>
class, which creates and/or configures the underlying component/endpoint.
Specify the full class name of the implementation.
You can set <code>connectorFactory</code> for the connector or for actions.
Actions have precedence.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Customizer example</div>
<p>The following customizer example sets up a <code>DataSource</code> from individual options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DataSourceCustomizer implements ComponentProxyCustomizer, CamelContextAware {
    private final static Logger LOGGER = LoggerFactory.getLogger(DataSourceCustomizer.class);

    private CamelContext camelContext;

    @Override
    public void setCamelContext(CamelContext camelContext) { <i class="conum" data-value="1"></i><b>(1)</b>
        this.camelContext = camelContext;
    }

    @Override
    public CamelContext getCamelContext() { <i class="conum" data-value="1"></i><b>(1)</b>
        return this.camelContext;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
        if (!options.containsKey("dataSource")) {
            if (options.containsKey("user") &amp;&amp; options.containsKey("password") &amp;&amp; options.containsKey("url")) {
                try {
                    BasicDataSource ds = new BasicDataSource();

                    consumeOption(camelContext, options, "user", String.class, ds::setUsername); <i class="conum" data-value="2"></i><b>(2)</b>
                    consumeOption(camelContext, options, "password", String.class, ds::setPassword); <i class="conum" data-value="2"></i><b>(2)</b>
                    consumeOption(camelContext, options, "url", String.class, ds::setUrl); <i class="conum" data-value="2"></i><b>(2)</b>

                    options.put("dataSource", ds);
                } catch (@SuppressWarnings("PMD.AvoidCatchingGenericException") Exception e) {
                    throw new IllegalArgumentException(e);
                }
            } else {
                LOGGER.debug("Not enough information provided to set-up the DataSource");
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>&nbsp;By implementing <code>CamelContextAware</code>, Syndesis injects the Camel context and then invokes the customize method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&nbsp;Processes options and then removes them from the options map.</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">Example of injecting properties</div>
<p>If the customizer respects Java bean conventions, you can also inject
the properties, as shown in this revision of the previous example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DataSourceCustomizer implements ComponentProxyCustomizer, CamelContextAware {
    private final static Logger LOGGER = LoggerFactory.getLogger(DataSourceCustomizer.class);

    private CamelContext camelContext;
    private String userName;
    private String password;
    private String url;

    @Override
    public void setCamelContext(CamelContext camelContext) { <i class="conum" data-value="1"></i><b>(1)</b>
        this.camelContext = camelContext;
    }

    @Override
    public CamelContext getCamelContext() { <i class="conum" data-value="1"></i><b>(1)</b>
        return this.camelContext;
    }

    public void setUserName(String userName) { <i class="conum" data-value="1"></i><b>(1)</b>
      this.userName = userName;
    }

    public String getUserName() { <i class="conum" data-value="2"></i><b>(2)</b>
      return this.userName;
    }

    public void setPassword(String password) { <i class="conum" data-value="2"></i><b>(2)</b>
      this.password = password;
    }

    public String getPassword() { <i class="conum" data-value="2"></i><b>(2)</b>
      return this.password;
    }

    public void setUrl(String url) { <i class="conum" data-value="2"></i><b>(2)</b>
      this.url = url;
    }

    public String getUrl() { <i class="conum" data-value="2"></i><b>(2)</b>
      return this.url;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
        if (!options.containsKey("dataSource")) {
            if (userName != null &amp;&amp; password != null &amp;&amp; url != null) {
                try {
                    BasicDataSource ds = new BasicDataSource();
                    ds.setUserName(userName);
                    ds.setPassword(password);
                    ds.setUrl(url);

                    options.put("dataSource", ds);
                } catch (@SuppressWarnings("PMD.AvoidCatchingGenericException") Exception e) {
                    throw new IllegalArgumentException(e);
                }
            } else {
                LOGGER.debug("Not enough information provided to set-up the DataSource");
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>&nbsp;By implementing <code>CamelContextAware</code>, Syndesis injects the Camel context
and then invokes the customize method. This sample code overrides the
<code>setCamelContext()</code> and <code>getCamelContext()</code> methods, and sets the user name.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&nbsp;The sample code processes the injected options and
automatically removes them from the options map.</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">Using a customizer to configure before/after logic</div>
<p>You can use a customizer to configure before/after logic as shown in this
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AWSS3DeleteObjectCustomizer implements ComponentProxyCustomizer {
  	private String filenameKey;

    public void setFilenameKey(String filenameKey) {
      this.filenameKey = filenameKey;
    }

    public String getFilenameKey() {
        return this.filenameKey;
    }

    @Override
    public void customize(ComponentProxyComponent component, Map&lt;String, Object&gt; options) {
      	component.setBeforeProducer(this::beforeProducer);
    }

    public void beforeProducer(final Exchange exchange) throws IOException {
      	exchange.getIn().setHeader(S3Constants.S3_OPERATION, S3Operations.deleteObject);

    	  if (filenameKey != null) {
    		    exchange.getIn().setHeader(S3Constants.KEY, filenameKey);
    	  }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Customizing behavior of <code>ComponentProxyComponent</code></div>
<p>The
<a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyFactory.java">ComponentProxyFactory</a>
class creates and/or configures the underlying component/endpoint.
To customize the behavior of the
<a href="https://github.com/syndesisio/syndesis/blob/master/app/integration/component-proxy/src/main/java/io/syndesis/integration/component/proxy/ComponentProxyComponent.java">ComponentProxyComponent</a>
object that <code>ComponentProxyFactory</code> creates, you can override any of the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>createDelegateComponent()</code></p>
<div class="paragraph">
<p>Syndesis invokes this method when the proxy starts and it is used to eventually
create a dedicated instance of the component with the scheme defined by the
<code>componentScheme</code> option.</p>
</div>
<div class="paragraph">
<p>The default behavior of this method is to determine if any of the
connector/action options applies at the component level. Only in the
case that the same option cannot be applied at the endpoint,
the method creates a custom component instance and configures it
according to the applicable options.</p>
</div>
</li>
<li>
<p><code>configureDelegateComponent()</code></p>
<div class="paragraph">
<p>Syndesis invokes this method only if a custom component instance has been
created to configure additional behavior of the delegated component instance.</p>
</div>
</li>
<li>
<p><code>createDelegateEndpoint()</code></p>
<div class="paragraph">
<p>Syndesis invokes this method when the proxy creates the endpoint and by
default creates the endpoint by using Camel catalog facilities.</p>
</div>
</li>
<li>
<p><code>configureDelegateEndpoint()</code></p>
<div class="paragraph">
<p>After the delegated endpoint has been created, Syndesis
invokes this method to configure additional behavior of the delegated endpoint
instance, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IrcComponentProxyFactory implements ComponentProxyFactory {

    @Override
    public ComponentProxyComponent newInstance(String componentId, String componentScheme) {
        return new ComponentProxyComponent(componentId, componentScheme) {
            @Override
            protected void configureDelegateEndpoint(ComponentDefinition definition, Endpoint endpoint, Map&lt;String, Object&gt; options) throws Exception {
                if (!(endpoint instanceof IrcEndpoint)) {
                    throw new IllegalStateException("Endpoint should be of type IrcEndpoint");
                }

                final IrcEndpoint ircEndpoint = (IrcEndpoint)endpoint;
                final String channels = (String)options.remove("channels");

                if (ObjectHelper.isNotEmpty(channels)) {
                    ircEndpoint.getConfiguration().setChannel(
                        Arrays.asList(channels.split(","))
                    );
                }
            }
        };
    }
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="develop-library-extensions_extensions"><a class="anchor" href="#develop-library-extensions_extensions"></a>How to develop library extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A library extension provides a resource that an
integration requires at runtime. A library extension does not contribute steps or
connectors to {prodname}.</p>
</div>
<div class="paragraph">
<p>When you save an integration, you can optionally select one or more imported library extensions that you want to include with the integration.</p>
</div>
<div class="paragraph">
<p>A library extension does not define any actions.
Here is a sample definition for a library extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schemaVersion" : "v1",
  "name" : "Example Library Extension",
  "description" : "Syndesis Extension for adding a runtime library",
  "extensionId" : "io.syndesis.extensions:syndesis-library",
  "version" : "1.0.0",
  "tags" : [ "my-libraries-extension" ],
  "extensionType" : "Libraries"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the sample library extension here:  <a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a></p>
</div>
<div class="paragraph">
<p>Other than the lack of actions, the structure of a library extension
is the same as the structure of a step or connector extension.</p>
</div>
<div class="paragraph">
<p>In a Maven project that creates a library extension, to add dependencies
that are not available from a Maven repository,
specify a <code>system</code> dependency, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.company&lt;/groupId&gt;
    &lt;artifactId&gt;my-library-extension&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${project.basedir}/lib/my-library-extension.jar&lt;/systemPath&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-jdbc-driver-library-extensions_extensions"><a class="anchor" href="#creating-jdbc-driver-library-extensions_extensions"></a>Creating JDBC driver library extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To connect to a SQL database other than Apache Derby, MySQL, and
PostgreSQL, you can create a library extension that wraps a JDBC driver for
the database you want to connect to.
After uploading this extension to {prodname}, the {prodname}-provided
<strong>Database</strong> connector can access the driver to validate and create connections
to the proprietary database. You do not create
a new connector for your particular database.</p>
</div>
<div class="paragraph">
<p>The Syndesis open source community provides a project for creating an
extension that wraps a JDBC driver.</p>
</div>
<div class="paragraph">
<p>Package one driver only in an extension. This makes
it easier to manage the extension as part of managing your particular database.
However, it is possible to create a library extension that wraps more than one driver.</p>
</div>
<div class="paragraph">
<div class="title">Prerequisites</div>
<p>To use the Syndesis project, you must have a GitHub account.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Ensure access to the JDBC driver for the database you want to connect to
by doing one of the following:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Confirm that the driver is in a Maven repository.</p>
</li>
<li>
<p>Download the driver.</p>
</li>
</ol>
</div>
</li>
<li>
<p>In a browser tab, go to
<a href="https://github.com/syndesisio/syndesis-extensions" class="bare">https://github.com/syndesisio/syndesis-extensions</a></p>
</li>
<li>
<p>Fork the <code>syndesis-extensions</code> repository to your GitHub account.</p>
</li>
<li>
<p>Create a local clone from your fork.</p>
</li>
<li>
<p>In your <code>syndesis-extensions</code> clone:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If the driver is not in a Maven repository, copy the
driver into the <code>syndesis-library-jdbc-driver/lib</code> folder.</p>
</li>
<li>
<p>Edit the <code>syndesis-library-jdbc-driver/pom.xml</code> file:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Update the value of the <code>Name</code> element to be a name that you choose
for this extension.</p>
</li>
<li>
<p>Update the value of the <code>Description</code> element to provide helpful
information about this extension.</p>
</li>
<li>
<p>If you have copied the driver into <code>syndesis-library-jdbc-driver/lib</code>
ensure that the <code>systemPath</code> in <code>pom.xml</code> points to that driver file. Optionally change
the <code>groupId</code>, <code>artifactId</code> and <code>version</code> to reflect proper values according to the driver.</p>
</li>
<li>
<p>If the driver is in a Maven repository, ensure that a reference to
that Maven dependency is in the <code>pom.xml</code> file.</p>
</li>
<li>
<p>Examine the rest of the content of the <code>pom.xml</code> file and change
any relevant metadata as needed.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Execute <code>./mvnw -pl :syndesis-library-jdbc-driver clean package</code> to build the extension.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The generated <code>.jar</code> file is in the <code>syndesis-library-jdbc-driver/target</code>
folder. Import this <code>.jar</code> file as an extension in {prodname}.</p>
</div>
<div class="paragraph">
<p>After you import a library extension, when you save an integration in {prodname} you can optionally select the imported library extension and associate it with the integration.</p>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
